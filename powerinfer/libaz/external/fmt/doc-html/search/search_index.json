{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"A modern formatting library","text":"Safety <p>   Inspired by Python's formatting facility, {fmt} provides a safe replacement   for the <code>printf</code> family of functions. Errors in format strings,   which are a common source of vulnerabilities in C, are reported at   compile time. For example:    <pre><code>fmt::format(\"{:d}\", \"I am not a number\");</code></pre>    will give a compile-time error because <code>d</code> is not a valid   format specifier for strings. APIs like  <code>fmt::format</code> prevent buffer overflow errors via   automatic memory management. </p> \u2192 Learn more Extensibility <p>   Formatting of most standard types, including all containers, dates,   and times is supported out-of-the-box. For example:    <pre><code>fmt::print(\"{}\", std::vector{1, 2, 3});</code></pre>    prints the vector in a JSON-like format:    <pre><code>[1, 2, 3]</code></pre>    You can make your own types formattable and even make compile-time   checks work for them. </p> \u2192 Learn more Performance <p>   {fmt} can be anywhere from tens of percent to 20-30 times faster than   iostreams and <code>sprintf</code>, especially for numeric formatting.       The library minimizes dynamic memory allocations and can optionally   compile format strings to optimal code. </p> Unicode support <p>   {fmt} provides portable Unicode support on major operating systems   with UTF-8 and <code>char</code> strings. For example:    <pre><code>fmt::print(\"\u0421\u043b\u0430\u0432\u0430 \u0423\u043a\u0440\u0430\u0457\u043d\u0456!\");</code></pre>    will be printed correctly on Linux, macOS, and even Windows console,   irrespective of the codepages. </p> <p>   The default is locale-independent, but you can opt into localized   formatting and {fmt} makes it work with Unicode, addressing issues in the   standard libary. </p> Fast compilation <p>   The library makes extensive use of type erasure to achieve fast   compilation. <code>fmt/base.h</code> provides a subset of the API with   minimal include dependencies and enough functionality to replace   all uses of <code>*printf</code>. </p> <p>   Code using {fmt} is usually several times faster to compile than the   equivalent iostreams code, and while <code>printf</code> compiles faster   still, the gap is narrowing. </p>  \u2192 Learn more Small binary footprint <p>   Type erasure is also used to prevent template bloat, resulting in compact   per-call binary code. For example, a call to <code>fmt::print</code> with   a single argument is just a few   instructions, comparable to <code>printf</code> despite adding   runtime safety, and much smaller than the equivalent iostreams code. </p> <p>   The library itself has small binary footprint and some components such as   floating-point formatting can be disabled to make it even smaller for   resource-constrained devices. </p> Portability <p>   {fmt} has a small self-contained codebase with the core consisting of   just three headers and no external dependencies. </p> <p>   The library is highly portable and requires only a minimal subset of   C++11 features which are available in GCC 4.9, Clang 3.6, MSVC 19.10   (2017) and later. Newer compiler and standard library features are used   if available, and enable additional functionality. </p> <p>   Where possible, the output of formatting functions is consistent across   platforms. </p> Open source <p>   {fmt} is in the top hundred open-source C++ libraries on GitHub and has   hundreds of   all-time contributors. </p> <p>   The library is distributed under a permissive MIT   license and is   relied upon by many open-source projects, including Blender, PyTorch,   Apple's FoundationDB, Windows Terminal, MongoDB, and others. </p>"},{"location":"api.html","title":"API Reference","text":"<p>The {fmt} library API consists of the following components:</p> <ul> <li><code>fmt/base.h</code>: the base API providing main formatting functions   for <code>char</code>/UTF-8 with C++20 compile-time checks and minimal dependencies</li> <li><code>fmt/format.h</code>: <code>fmt::format</code> and other formatting functions   as well as locale support</li> <li><code>fmt/ranges.h</code>: formatting of ranges and tuples</li> <li><code>fmt/chrono.h</code>: date and time formatting</li> <li><code>fmt/std.h</code>: formatters for standard library types</li> <li><code>fmt/compile.h</code>: format string compilation</li> <li><code>fmt/color.h</code>: terminal colors and text styles</li> <li><code>fmt/os.h</code>: system APIs</li> <li><code>fmt/ostream.h</code>: <code>std::ostream</code> support</li> <li><code>fmt/args.h</code>: dynamic argument lists</li> <li><code>fmt/printf.h</code>: safe <code>printf</code></li> <li><code>fmt/xchar.h</code>: optional <code>wchar_t</code> support</li> </ul> <p>All functions and types provided by the library reside in namespace <code>fmt</code> and macros have prefix <code>FMT_</code>.</p>"},{"location":"api.html#base-api","title":"Base API","text":"<p><code>fmt/base.h</code> defines the base API which provides main formatting functions for <code>char</code>/UTF-8 with C++20 compile-time checks. It has minimal include dependencies for better compile times. This header is only beneficial when using {fmt} as a library (the default) and not in the header-only mode. It also provides <code>formatter</code> specializations for the following types:</p> <ul> <li><code>int</code>, <code>long long</code>,</li> <li><code>unsigned</code>, <code>unsigned long long</code></li> <li><code>float</code>, <code>double</code>, <code>long double</code></li> <li><code>bool</code></li> <li><code>char</code></li> <li><code>const char*</code>, <code>fmt::string_view</code></li> <li><code>const void*</code></li> </ul> <p>The following functions use format string syntax similar to that of str.format in Python. They take fmt and args as arguments.</p> <p>fmt is a format string that contains literal text and replacement fields surrounded by braces <code>{}</code>. The fields are replaced with formatted arguments in the resulting string. <code>fmt::format_string</code> is a format string which can be implicitly constructed from a string literal or a <code>constexpr</code> string and is checked at compile time in C++20. To pass a runtime format string wrap it in <code>fmt::runtime</code>.</p> <p>args is an argument list representing objects to be formatted.</p> <p>I/O errors are reported as <code>std::system_error</code> exceptions unless specified otherwise.</p> <pre><code>template &lt;typename...\u00a0T&gt;\nvoid print(format_string&lt;T...&gt; fmt, T&amp;&amp;... args);</code></pre> <p>Formats <code>args</code> according to specifications in <code>fmt</code> and writes the output to <code>stdout</code>.</p> <p>Example: <pre><code>fmt::print(\"The answer is {}.\", 42);\n</code></pre> </p> <pre><code>template &lt;typename...\u00a0T&gt;\nvoid print(FILE* f, format_string&lt;T...&gt; fmt, T&amp;&amp;... args);</code></pre> <p>Formats <code>args</code> according to specifications in <code>fmt</code> and writes the output to the file <code>f</code>.</p> <p>Example: <pre><code>fmt::print(stderr, \"Don't {}!\", \"panic\");\n</code></pre> </p> <pre><code>template &lt;typename...\u00a0T&gt;\nvoid println(format_string&lt;T...&gt; fmt, T&amp;&amp;... args);</code></pre> <p>Formats <code>args</code> according to specifications in <code>fmt</code> and writes the output to <code>stdout</code> followed by a newline. </p> <pre><code>template &lt;typename...\u00a0T&gt;\nvoid println(FILE* f, format_string&lt;T...&gt; fmt, T&amp;&amp;... args);</code></pre> <p>Formats <code>args</code> according to specifications in <code>fmt</code> and writes the output to the file <code>f</code> followed by a newline. </p> <pre><code>template &lt;typename OutputIt, typename...\u00a0T&gt;\nauto format_to(OutputIt&amp;&amp; out, format_string&lt;T...&gt; fmt, T&amp;&amp;... args) -\u2060&gt;\u00a0remove_cvref_t&lt;OutputIt&gt;;</code></pre> <p>Formats <code>args</code> according to specifications in <code>fmt</code>, writes the result to the output iterator <code>out</code> and returns the iterator past the end of the output range. <code>format_to</code> does not append a terminating null character.</p> <p>Example: <pre><code>auto out = std::vector&lt;char&gt;();\nfmt::format_to(std::back_inserter(out), \"{}\", 42);\n</code></pre> </p> <pre><code>template &lt;typename OutputIt, typename...\u00a0T&gt;\nauto format_to_n(OutputIt out, size_t n, format_string&lt;T...&gt; fmt, T&amp;&amp;... args) -\u2060&gt;\u00a0format_to_n_result&lt;OutputIt&gt;;</code></pre> <p>Formats <code>args</code> according to specifications in <code>fmt</code>, writes up to <code>n</code> characters of the result to the output iterator <code>out</code> and returns the total (not truncated) output size and the iterator past the end of the output range. <code>format_to_n</code> does not append a terminating null character. </p> <pre><code>template &lt;typename OutputIt&gt;\nstruct format_to_n_result;</code></pre> <pre><code>OutputIt out;</code></pre> <p>Iterator past the end of the output range. </p> <pre><code>size_t size;</code></pre> <p>Total (not truncated) output size. </p> <pre><code>template &lt;typename...\u00a0T&gt;\nauto formatted_size(format_string&lt;T...&gt; fmt, T&amp;&amp;... args) -\u2060&gt;\u00a0size_t;</code></pre> <p>Returns the number of chars in the output of <code>format(fmt, args...)</code>. </p> <p></p>"},{"location":"api.html#formatting-user-defined-types","title":"Formatting User-Defined Types","text":"<p>The {fmt} library provides formatters for many standard C++ types. See <code>fmt/ranges.h</code> for ranges and tuples including standard containers such as <code>std::vector</code>, <code>fmt/chrono.h</code> for date and time formatting and <code>fmt/std.h</code> for other standard library types.</p> <p>There are two ways to make a user-defined type formattable: providing a <code>format_as</code> function or specializing the <code>formatter</code> struct template.</p> <p>Use <code>format_as</code> if you want to make your type formattable as some other type with the same format specifiers. The <code>format_as</code> function should take an object of your type and return an object of a formattable type. It should be defined in the same namespace as your type.</p> <p>Example (run):</p> <pre><code>#include &lt;fmt/format.h&gt;\n\nnamespace kevin_namespacy {\n\nenum class film {\n  house_of_cards, american_beauty, se7en = 7\n};\n\nauto format_as(film f) { return fmt::underlying(f); }\n\n}\n\nint main() {\n  fmt::print(\"{}\\n\", kevin_namespacy::film::se7en); // Output: 7\n}</code></pre> <p>Using specialization is more complex but gives you full control over parsing and formatting. To use this method specialize the <code>formatter</code> struct template for your type and implement <code>parse</code> and <code>format</code> methods.</p> <p>The recommended way of defining a formatter is by reusing an existing one via inheritance or composition. This way you can support standard format specifiers without implementing them yourself. For example:</p> <pre><code>// color.h:\n#include &lt;fmt/base.h&gt;\n\nenum class color {red, green, blue};\n\ntemplate &lt;&gt; struct fmt::formatter&lt;color&gt;: formatter&lt;string_view&gt; {\n  // parse is inherited from formatter&lt;string_view&gt;.\n\n  auto format(color c, format_context&amp; ctx) const\n    -&gt; format_context::iterator;\n};\n</code></pre> <pre><code>// color.cc:\n#include \"color.h\"\n#include &lt;fmt/format.h&gt;\n\nauto fmt::formatter&lt;color&gt;::format(color c, format_context&amp; ctx) const\n    -&gt; format_context::iterator {\n  string_view name = \"unknown\";\n  switch (c) {\n  case color::red:   name = \"red\"; break;\n  case color::green: name = \"green\"; break;\n  case color::blue:  name = \"blue\"; break;\n  }\n  return formatter&lt;string_view&gt;::format(name, ctx);\n}\n</code></pre> <p>Note that <code>formatter&lt;string_view&gt;::format</code> is defined in <code>fmt/format.h</code> so it has to be included in the source file. Since <code>parse</code> is inherited from <code>formatter&lt;string_view&gt;</code> it will recognize all string format specifications, for example</p> <pre><code>fmt::format(\"{:&gt;10}\", color::blue)\n</code></pre> <p>will return <code>\"      blue\"</code>.</p> <p>In general the formatter has the following form:</p> <pre><code>template &lt;&gt; struct fmt::formatter&lt;T&gt; {\n  // Parses format specifiers and stores them in the formatter.\n  //\n  // [ctx.begin(), ctx.end()) is a, possibly empty, character range that\n  // contains a part of the format string starting from the format\n  // specifications to be parsed, e.g. in\n  //\n  //   fmt::format(\"{:f} continued\", ...);\n  //\n  // the range will contain \"f} continued\". The formatter should parse\n  // specifiers until '}' or the end of the range. In this example the\n  // formatter should parse the 'f' specifier and return an iterator\n  // pointing to '}'.\n  constexpr auto parse(format_parse_context&amp; ctx)\n    -&gt; format_parse_context::iterator;\n\n  // Formats value using the parsed format specification stored in this\n  // formatter and writes the output to ctx.out().\n  auto format(const T&amp; value, format_context&amp; ctx) const\n    -&gt; format_context::iterator;\n};</code></pre> <p>It is recommended to at least support fill, align and width that apply to the whole object and have the same semantics as in standard formatters.</p> <p>You can also write a formatter for a hierarchy of classes:</p> <pre><code>// demo.h:\n#include &lt;type_traits&gt;\n#include &lt;fmt/format.h&gt;\n\nstruct A {\n  virtual ~A() {}\n  virtual std::string name() const { return \"A\"; }\n};\n\nstruct B : A {\n  virtual std::string name() const { return \"B\"; }\n};\n\ntemplate &lt;typename T&gt;\nstruct fmt::formatter&lt;T, std::enable_if_t&lt;std::is_base_of_v&lt;A, T&gt;, char&gt;&gt; :\n    fmt::formatter&lt;std::string&gt; {\n  auto format(const A&amp; a, format_context&amp; ctx) const {\n    return formatter&lt;std::string&gt;::format(a.name(), ctx);\n  }\n};\n</code></pre> <pre><code>// demo.cc:\n#include \"demo.h\"\n#include &lt;fmt/format.h&gt;\n\nint main() {\n  B b;\n  A&amp; a = b;\n  fmt::print(\"{}\", a); // Output: B\n}\n</code></pre> <p>Providing both a <code>formatter</code> specialization and a <code>format_as</code> overload is disallowed.</p> <pre><code>template &lt;typename Char&gt;\nusing basic_format_parse_context = parse_context&lt;Char&gt;;</code></pre> <pre><code>class context;</code></pre> <pre><code>context(iterator out, format_args args, detail::locale_ref loc);</code></pre> <p>Constructs a <code>context</code> object. References to the arguments are stored in the object so make sure they have appropriate lifetimes. </p> <pre><code>using format_context = context;</code></pre>"},{"location":"api.html#compile-time-checks","title":"Compile-Time Checks","text":"<p>Compile-time format string checks are enabled by default on compilers that support C++20 <code>consteval</code>. On older compilers you can use the FMT_STRING macro defined in <code>fmt/format.h</code> instead.</p> <p>Unused arguments are allowed as in Python's <code>str.format</code> and ordinary functions.</p> <p>See Type Erasure for an example of how to enable compile-time checks in your own functions with <code>fmt::format_string</code> while avoiding template bloat.</p> <pre><code>template &lt;typename...\u00a0T&gt;\nstruct fstring;</code></pre> <p>A compile-time format string. Use <code>format_string</code> in the public API to prevent type deduction. </p> <pre><code>template &lt;typename...\u00a0T&gt;\nusing format_string = typename fstring&lt;T...&gt;::t;</code></pre> <pre><code>auto runtime(string_view s) -\u2060&gt;\u00a0runtime_format_string&lt;&gt;;</code></pre> <p>Creates a runtime format string.</p> <p>Example: <pre><code>// Check format string at runtime instead of compile-time.\nfmt::print(fmt::runtime(\"{:d}\"), \"I am not a number\");\n</code></pre> </p>"},{"location":"api.html#type-erasure","title":"Type Erasure","text":"<p>You can create your own formatting function with compile-time checks and small binary footprint, for example (run):</p> <pre><code>#include &lt;fmt/format.h&gt;\n\nvoid vlog(const char* file, int line,\n          fmt::string_view fmt, fmt::format_args args) {\n  fmt::print(\"{}: {}: {}\", file, line, fmt::vformat(fmt, args));\n}\n\ntemplate &lt;typename... T&gt;\nvoid log(const char* file, int line,\n         fmt::format_string&lt;T...&gt; fmt, T&amp;&amp;... args) {\n  vlog(file, line, fmt, fmt::make_format_args(args...));\n}\n\n#define MY_LOG(fmt, ...) log(__FILE__, __LINE__, fmt, __VA_ARGS__)\n\nMY_LOG(\"invalid squishiness: {}\", 42);\n</code></pre> <p>Note that <code>vlog</code> is not parameterized on argument types which improves compile times and reduces binary code size compared to a fully parameterized version.</p> <pre><code>template &lt;typename Context, typename...\u00a0T, int\u00a0NUM_ARGS, int\u00a0NUM_NAMED_ARGS, unsigned long long\u00a0DESC&gt;\nconstexpr auto make_format_args(T&amp;... args) -\u2060&gt;\u00a0detail::format_arg_store&lt;Context, NUM_ARGS, NUM_NAMED_ARGS, DESC&gt;;</code></pre> <p>Constructs an object that stores references to arguments and can be implicitly converted to <code>format_args</code>. <code>Context</code> can be omitted in which case it defaults to <code>context</code>. See <code>arg</code> for lifetime considerations. </p> <pre><code>template &lt;typename Context&gt;\nclass basic_format_args;</code></pre> <p>A view of a collection of formatting arguments. To avoid lifetime issues it should only be used as a parameter type in type-erased functions such as <code>vformat</code>: <pre><code>void vlog(fmt::string_view fmt, fmt::format_args args);  // OK\nfmt::format_args args = fmt::make_format_args();  // Dangling reference\n</code></pre> </p> <pre><code>constexpr basic_format_args(const store&lt;NUM_ARGS, NUM_NAMED_ARGS, DESC&gt;&amp; s);</code></pre> <p>Constructs a <code>basic_format_args</code> object from <code>format_arg_store</code>. </p> <pre><code>constexpr basic_format_args(const format_arg* args, int count, bool has_named);</code></pre> <p>Constructs a <code>basic_format_args</code> object from a dynamic list of arguments. </p> <pre><code>auto get(int id) -\u2060&gt;\u00a0format_arg;</code></pre> <p>Returns the argument with the specified id. </p> <pre><code>using format_args = basic_format_args&lt;context&gt;;</code></pre> <pre><code>template &lt;typename Context&gt;\nclass basic_format_arg;</code></pre> <pre><code>auto visit(Visitor&amp;&amp; vis) -\u2060&gt;\u00a0decltype(vis(0));</code></pre> <p>Visits an argument dispatching to the appropriate visit method based on the argument type. For example, if the argument type is <code>double</code> then <code>vis(value)</code> will be called with the value of type <code>double</code>. </p>"},{"location":"api.html#named-arguments","title":"Named Arguments","text":"<pre><code>template &lt;typename Char, typename T&gt;\nauto arg(const Char* name, const T&amp; arg) -\u2060&gt;\u00a0detail::named_arg&lt;Char, T&gt;;</code></pre> <p>Returns a named argument to be used in a formatting function. It should only be used in a call to a formatting function.</p> <p>Example: <pre><code>fmt::print(\"The answer is {answer}.\", fmt::arg(\"answer\", 42));\n</code></pre> </p> <p>Named arguments are not supported in compile-time checks at the moment.</p>"},{"location":"api.html#compatibility","title":"Compatibility","text":"<pre><code>template &lt;typename Char&gt;\nclass basic_string_view;</code></pre> <p>An implementation of <code>std::basic_string_view</code> for pre-C++17. It provides a subset of the API. <code>fmt::basic_string_view</code> is used for format strings even if <code>std::basic_string_view</code> is available to prevent issues when a library is compiled with a different <code>-std</code> option than the client code (which is not recommended). </p> <pre><code>constexpr basic_string_view(const Char* s, size_t count);</code></pre> <p>Constructs a string view object from a C string and a size. </p> <pre><code>basic_string_view(const Char* s);</code></pre> <p>Constructs a string view object from a C string. </p> <pre><code>basic_string_view(const S&amp; s);</code></pre> <p>Constructs a string view from a <code>std::basic_string</code> or a <code>std::basic_string_view</code> object. </p> <pre><code>constexpr auto data() -\u2060&gt;\u00a0const Char*;</code></pre> <p>Returns a pointer to the string data. </p> <pre><code>constexpr auto size() -\u2060&gt;\u00a0size_t;</code></pre> <p>Returns the string size. </p> <pre><code>using string_view = basic_string_view&lt;char&gt;;</code></pre>"},{"location":"api.html#format-api","title":"Format API","text":"<p><code>fmt/format.h</code> defines the full format API providing additional formatting functions and locale support.</p> <p> </p> <pre><code>template &lt;typename...\u00a0T&gt;\nauto format(format_string&lt;T...&gt; fmt, T&amp;&amp;... args) -\u2060&gt;\u00a0std::string;</code></pre> <p>Formats <code>args</code> according to specifications in <code>fmt</code> and returns the result as a string.</p> <p>Example: <pre><code>#include &lt;fmt/format.h&gt;\nstd::string message = fmt::format(\"The answer is {}.\", 42);\n</code></pre> </p> <pre><code>auto vformat(string_view fmt, format_args args) -\u2060&gt;\u00a0std::string;</code></pre> <pre><code>template &lt;detail::fixed_string\u00a0S&gt;\nconstexpr auto operator\"\"_a();</code></pre>"},{"location":"api.html#utilities","title":"Utilities","text":"<pre><code>template &lt;typename T&gt;\nauto ptr(T p) -\u2060&gt;\u00a0const void*;</code></pre> <p>Converts <code>p</code> to <code>const void*</code> for pointer formatting.</p> <p>Example: <pre><code>auto s = fmt::format(\"{}\", fmt::ptr(p));\n</code></pre> </p> <pre><code>template &lt;typename Enum&gt;\nconstexpr auto underlying(Enum e) -\u2060&gt;\u00a0underlying_t&lt;Enum&gt;;</code></pre> <p>Converts <code>e</code> to the underlying type.</p> <p>Example: <pre><code>enum class color { red, green, blue };\nauto s = fmt::format(\"{}\", fmt::underlying(color::red));  // s == \"0\"\n</code></pre> </p> <pre><code>template &lt;typename T&gt;\nauto to_string(const T&amp; value) -\u2060&gt;\u00a0std::string;</code></pre> <pre><code>template &lt;typename T&gt;\nauto group_digits(T value) -\u2060&gt;\u00a0group_digits_view&lt;T&gt;;</code></pre> <p>Returns a view that formats an integer value using ',' as a locale-independent thousands separator.</p> <p>Example: <pre><code>fmt::print(\"{}\", fmt::group_digits(12345));\n// Output: \"12,345\"\n</code></pre> </p> <pre><code>template &lt;typename T&gt;\nclass detail::buffer;</code></pre> <p>A contiguous memory buffer with an optional growing ability. It is an internal class and shouldn't be used directly, only via <code>memory_buffer</code>. </p> <pre><code>constexpr auto size() -\u2060&gt;\u00a0size_t;</code></pre> <p>Returns the size of this buffer. </p> <pre><code>constexpr auto capacity() -\u2060&gt;\u00a0size_t;</code></pre> <p>Returns the capacity of this buffer. </p> <pre><code>auto data() -\u2060&gt;\u00a0T*;</code></pre> <p>Returns a pointer to the buffer data (not null-terminated). </p> <pre><code>void clear();</code></pre> <p>Clears this buffer. </p> <pre><code>void append(const U* begin, const U* end);</code></pre> <p>Appends data to the end of the buffer. </p> <pre><code>template &lt;typename T, size_t\u00a0SIZE, typename Allocator&gt;\nclass basic_memory_buffer;</code></pre> <p>A dynamically growing memory buffer for trivially copyable/constructible types with the first <code>SIZE</code> elements stored in the object itself. Most commonly used via the <code>memory_buffer</code> alias for <code>char</code>.</p> <p>Example: <pre><code>auto out = fmt::memory_buffer();\nfmt::format_to(std::back_inserter(out), \"The answer is {}.\", 42);\n</code></pre> This will append \"The answer is 42.\" to <code>out</code>. The buffer content can be converted to <code>std::string</code> with <code>to_string(out)</code>. </p> <pre><code>basic_memory_buffer(basic_memory_buffer&amp;&amp; other);</code></pre> <p>Constructs a <code>basic_memory_buffer</code> object moving the content of the other object to it. </p> <pre><code>auto operator=(basic_memory_buffer&amp;&amp; other) -\u2060&gt;\u00a0basic_memory_buffer&amp;;</code></pre> <p>Moves the content of the other <code>basic_memory_buffer</code> object to this one. </p> <pre><code>void resize(size_t count);</code></pre> <p>Resizes the buffer to contain <code>count</code> elements. If T is a POD type new elements may not be initialized. </p> <pre><code>void reserve(size_t new_capacity);</code></pre> <p>Increases the buffer capacity to <code>new_capacity</code>. </p>"},{"location":"api.html#system-errors","title":"System Errors","text":"<p>{fmt} does not use <code>errno</code> to communicate errors to the user, but it may call system functions which set <code>errno</code>. Users should not make any assumptions about the value of <code>errno</code> being preserved by library functions.</p> <pre><code>template &lt;typename...\u00a0T&gt;\nauto system_error(int error_code, format_string&lt;T...&gt; fmt, T&amp;&amp;... args) -\u2060&gt;\u00a0std::system_error;</code></pre> <p>Constructs <code>std::system_error</code> with a message formatted with <code>fmt::format(fmt, args...)</code>. <code>error_code</code> is a system error code as given by <code>errno</code>.</p> <p>Example: <pre><code>// This throws std::system_error with the description\n//   cannot open file 'madeup': No such file or directory\n// or similar (system message may vary).\nconst char* filename = \"madeup\";\nFILE* file = fopen(filename, \"r\");\nif (!file)\n  throw fmt::system_error(errno, \"cannot open file '{}'\", filename);\n</code></pre> </p> <pre><code>void format_system_error(detail::buffer&lt;char&gt;&amp; out, int error_code, const char* message);</code></pre> <p>Formats an error message for an error returned by an operating system or a language runtime, for example a file opening error, and writes it to <code>out</code>. The format is the same as the one used by <code>std::system_error(ec, message)</code> where <code>ec</code> is <code>std::error_code(error_code, std::generic_category())</code>. It is implementation-defined but normally looks like: <pre><code>&lt;message&gt;: &lt;system-message&gt;\n</code></pre> where <code>&lt;message&gt;</code> is the passed message and <code>&lt;system-message&gt;</code> is the system message corresponding to the error code. <code>error_code</code> is a system error code as given by <code>errno</code>. </p>"},{"location":"api.html#custom-allocators","title":"Custom Allocators","text":"<p>The {fmt} library supports custom dynamic memory allocators. A custom allocator class can be specified as a template argument to <code>fmt::basic_memory_buffer</code>:</p> <pre><code>using custom_memory_buffer = \n  fmt::basic_memory_buffer&lt;char, fmt::inline_buffer_size, custom_allocator&gt;;</code></pre> <p>It is also possible to write a formatting function that uses a custom allocator:</p> <pre><code>using custom_string =\n  std::basic_string&lt;char, std::char_traits&lt;char&gt;, custom_allocator&gt;;\n\nauto vformat(custom_allocator alloc, fmt::string_view fmt,\n             fmt::format_args args) -&gt; custom_string {\n  auto buf = custom_memory_buffer(alloc);\n  fmt::vformat_to(std::back_inserter(buf), fmt, args);\n  return custom_string(buf.data(), buf.size(), alloc);\n}\n\ntemplate &lt;typename ...Args&gt;\nauto format(custom_allocator alloc, fmt::string_view fmt,\n            const Args&amp; ... args) -&gt; custom_string {\n  return vformat(alloc, fmt, fmt::make_format_args(args...));\n}</code></pre> <p>The allocator will be used for the output container only. Formatting functions normally don't do any allocations for built-in and string types except for non-default floating-point formatting that occasionally falls back on <code>sprintf</code>.</p>"},{"location":"api.html#locale","title":"Locale","text":"<p>All formatting is locale-independent by default. Use the <code>'L'</code> format specifier to insert the appropriate number separator characters from the locale:</p> <pre><code>#include &lt;fmt/format.h&gt;\n#include &lt;locale&gt;\n\nstd::locale::global(std::locale(\"en_US.UTF-8\"));\nauto s = fmt::format(\"{:L}\", 1000000);  // s == \"1,000,000\"</code></pre> <p><code>fmt/format.h</code> provides the following overloads of formatting functions that take <code>std::locale</code> as a parameter. The locale type is a template parameter to avoid the expensive <code>&lt;locale&gt;</code> include.</p> <pre><code>template &lt;typename Locale, typename...\u00a0T&gt;\nauto format(const Locale&amp; loc, format_string&lt;T...&gt; fmt, T&amp;&amp;... args) -\u2060&gt;\u00a0std::string;</code></pre> <pre><code>template &lt;typename OutputIt, typename Locale, typename...\u00a0T&gt;\nauto format_to(OutputIt out, const Locale&amp; loc, format_string&lt;T...&gt; fmt, T&amp;&amp;... args) -\u2060&gt;\u00a0OutputIt;</code></pre> <pre><code>template &lt;typename Locale, typename...\u00a0T&gt;\nauto formatted_size(const Locale&amp; loc, format_string&lt;T...&gt; fmt, T&amp;&amp;... args) -\u2060&gt;\u00a0size_t;</code></pre> <p></p>"},{"location":"api.html#legacy-compile-time-checks","title":"Legacy Compile-Time Checks","text":"<p><code>FMT_STRING</code> enables compile-time checks on older compilers. It requires C++14 or later and is a no-op in C++11.</p> <pre><code>FMT_STRING(s)</code></pre> <p>Constructs a legacy compile-time format string from a string literal <code>s</code>.</p> <p>Example: <pre><code>// A compile-time error because 'd' is an invalid specifier for strings.\nstd::string s = fmt::format(FMT_STRING(\"{:d}\"), \"foo\");\n</code></pre> </p> <p>To force the use of legacy compile-time checks, define the preprocessor variable <code>FMT_ENFORCE_COMPILE_STRING</code>. When set, functions accepting <code>FMT_STRING</code> will fail to compile with regular strings.</p> <p></p>"},{"location":"api.html#range-and-tuple-formatting","title":"Range and Tuple Formatting","text":"<p><code>fmt/ranges.h</code> provides formatting support for ranges and tuples:</p> <pre><code>#include &lt;fmt/ranges.h&gt;\n\nfmt::print(\"{}\", std::tuple&lt;char, int&gt;{'a', 42});\n// Output: ('a', 42)</code></pre> <p>Using <code>fmt::join</code>, you can separate tuple elements with a custom separator:</p> <pre><code>#include &lt;fmt/ranges.h&gt;\n\nauto t = std::tuple&lt;int, char&gt;{1, 'a'};\nfmt::print(\"{}\", fmt::join(t, \", \"));\n// Output: 1, a</code></pre> <pre><code>template &lt;typename Range&gt;\nauto join(Range&amp;&amp; r, string_view sep) -\u2060&gt;\u00a0join_view&lt;decltype(detail::range_begin(r)), decltype(detail::range_end(r))&gt;;</code></pre> <p>Returns a view that formats <code>range</code> with elements separated by <code>sep</code>.</p> <p>Example: <pre><code>auto v = std::vector&lt;int&gt;{1, 2, 3};\nfmt::print(\"{}\", fmt::join(v, \", \"));\n// Output: 1, 2, 3\n</code></pre> <code>fmt::join</code> applies passed format specifiers to the range elements: <pre><code>fmt::print(\"{:02}\", fmt::join(v, \", \"));\n// Output: 01, 02, 03\n</code></pre> </p> <pre><code>template &lt;typename It, typename Sentinel&gt;\nauto join(It begin, Sentinel end, string_view sep) -\u2060&gt;\u00a0join_view&lt;It, Sentinel&gt;;</code></pre> <p>Returns a view that formats the iterator range <code>[begin, end)</code> with elements separated by <code>sep</code>. </p> <pre><code>template &lt;typename T&gt;\nauto join(std::initializer_list&lt;T&gt; list, string_view sep) -\u2060&gt;\u00a0join_view&lt;const T*, const T*&gt;;</code></pre> <p>Returns an object that formats <code>std::initializer_list</code> with elements separated by <code>sep</code>.</p> <p>Example: <pre><code>fmt::print(\"{}\", fmt::join({1, 2, 3}, \", \"));\n// Output: \"1, 2, 3\"\n</code></pre> </p> <p></p>"},{"location":"api.html#date-and-time-formatting","title":"Date and Time Formatting","text":"<p><code>fmt/chrono.h</code> provides formatters for</p> <ul> <li><code>std::chrono::duration</code></li> <li><code>std::chrono::time_point</code></li> <li><code>std::tm</code></li> </ul> <p>The format syntax is described in Chrono Format Specifications.</p> <p>Example:</p> <pre><code>#include &lt;fmt/chrono.h&gt;\n\nint main() {\n  auto now = std::chrono::system_clock::now();\n\n  fmt::print(\"The date is {:%Y-%m-%d}.\\n\", now);\n  // Output: The date is 2020-11-07.\n  // (with 2020-11-07 replaced by the current date)\n\n  using namespace std::literals::chrono_literals;\n\n  fmt::print(\"Default format: {} {}\\n\", 42s, 100ms);\n  // Output: Default format: 42s 100ms\n\n  fmt::print(\"strftime-like format: {:%H:%M:%S}\\n\", 3h + 15min + 30s);\n  // Output: strftime-like format: 03:15:30\n}</code></pre> <pre><code>auto gmtime(std::time_t time) -\u2060&gt;\u00a0std::tm;</code></pre> <p>Converts given time since epoch as <code>std::time_t</code> value into calendar time, expressed in Coordinated Universal Time (UTC). Unlike <code>std::gmtime</code>, this function is thread-safe on most platforms. </p> <p></p>"},{"location":"api.html#standard-library-types-formatting","title":"Standard Library Types Formatting","text":"<p><code>fmt/std.h</code> provides formatters for:</p> <ul> <li><code>std::atomic</code></li> <li><code>std::atomic_flag</code></li> <li><code>std::bitset</code></li> <li><code>std::error_code</code></li> <li><code>std::exception</code></li> <li><code>std::filesystem::path</code></li> <li><code>std::monostate</code></li> <li><code>std::optional</code></li> <li><code>std::source_location</code></li> <li><code>std::thread::id</code></li> <li><code>std::variant</code></li> </ul> <pre><code>template &lt;typename T, typename Deleter&gt;\nauto ptr(const std::unique_ptr&lt;T, Deleter&gt;&amp; p) -\u2060&gt;\u00a0const void*;</code></pre> <pre><code>template &lt;typename T&gt;\nauto ptr(const std::shared_ptr&lt;T&gt;&amp; p) -\u2060&gt;\u00a0const void*;</code></pre>"},{"location":"api.html#variants","title":"Variants","text":"<p>A <code>std::variant</code> is only formattable if every variant alternative is formattable, and requires the <code>__cpp_lib_variant</code> library feature.</p> <p>Example:</p> <pre><code>#include &lt;fmt/std.h&gt;\n\nfmt::print(\"{}\", std::variant&lt;char, float&gt;('x'));\n// Output: variant('x')\n\nfmt::print(\"{}\", std::variant&lt;std::monostate, char&gt;());\n// Output: variant(monostate)</code></pre>"},{"location":"api.html#bit-fields-and-packed-structs","title":"Bit-Fields and Packed Structs","text":"<p>To format a bit-field or a field of a struct with <code>__attribute__((packed))</code> applied to it, you need to convert it to the underlying or compatible type via a cast or a unary <code>+</code> (godbolt):</p> <pre><code>struct smol {\n  int bit : 1;\n};\n\nauto s = smol();\nfmt::print(\"{}\", +s.bit);\n</code></pre> <p>This is a known limitation of \"perfect\" forwarding in C++.</p> <p></p>"},{"location":"api.html#format-string-compilation","title":"Format String Compilation","text":"<p><code>fmt/compile.h</code> provides format string compilation and compile-time (<code>constexpr</code>) formatting enabled via the <code>FMT_COMPILE</code> macro or the <code>_cf</code> user-defined literal defined in namespace <code>fmt::literals</code>. Format strings marked with <code>FMT_COMPILE</code> or <code>_cf</code> are parsed, checked and converted into efficient formatting code at compile-time. This supports arguments of built-in and string types as well as user-defined types with <code>format</code> functions taking the format context type as a template parameter in their <code>formatter</code> specializations. For example:</p> <pre><code>template &lt;&gt; struct fmt::formatter&lt;point&gt; {\n  constexpr auto parse(format_parse_context&amp; ctx);\n\n  template &lt;typename FormatContext&gt;\n  auto format(const point&amp; p, FormatContext&amp; ctx) const;\n};</code></pre> <p>Format string compilation can generate more binary code compared to the default API and is only recommended in places where formatting is a performance bottleneck.</p> <pre><code>FMT_COMPILE(s)</code></pre> <p>Converts a string literal <code>s</code> into a format string that will be parsed at compile time and converted into efficient formatting code. Requires C++17 <code>constexpr if</code> compiler support.</p> <p>Example: <pre><code>// Converts 42 into std::string using the most efficient method and no\n// runtime format string processing.\nstd::string s = fmt::format(FMT_COMPILE(\"{}\"), 42);\n</code></pre> </p> <pre><code>template &lt;detail::fixed_string\u00a0Str&gt;\nconstexpr auto operator\"\"_cf();</code></pre> <p></p>"},{"location":"api.html#terminal-colors-and-text-styles","title":"Terminal Colors and Text Styles","text":"<p><code>fmt/color.h</code> provides support for terminal color and text style output.</p> <pre><code>template &lt;typename...\u00a0T&gt;\nvoid print(text_style ts, format_string&lt;T...&gt; fmt, T&amp;&amp;... args);</code></pre> <p>Formats a string and prints it to stdout using ANSI escape sequences to specify text formatting.</p> <p>Example: <pre><code>fmt::print(fmt::emphasis::bold | fg(fmt::color::red),\n           \"Elapsed time: {0:.2f} seconds\", 1.23);\n</code></pre> </p> <pre><code>auto fg(detail::color_type foreground) -\u2060&gt;\u00a0text_style;</code></pre> <p>Creates a text style from the foreground (text) color. </p> <pre><code>auto bg(detail::color_type background) -\u2060&gt;\u00a0text_style;</code></pre> <p>Creates a text style from the background color. </p> <pre><code>template &lt;typename T&gt;\nauto styled(const T&amp; value, text_style ts) -\u2060&gt;\u00a0detail::styled_arg&lt;remove_cvref_t&lt;T&gt;&gt;;</code></pre> <p>Returns an argument that will be formatted using ANSI escape sequences, to be used in a formatting function.</p> <p>Example: <pre><code>fmt::print(\"Elapsed time: {0:.2f} seconds\",\n           fmt::styled(1.23, fmt::fg(fmt::color::green) |\n                             fmt::bg(fmt::color::blue)));\n</code></pre> </p> <p></p>"},{"location":"api.html#system-apis","title":"System APIs","text":"<pre><code>class ostream;</code></pre> <p>A fast buffered output stream for writing from a single thread. Writing from multiple threads without external synchronization may result in a data race. </p> <pre><code>void print(format_string&lt;T...&gt; fmt, T&amp;&amp;... args);</code></pre> <p>Formats <code>args</code> according to specifications in <code>fmt</code> and writes the output to the file. </p> <pre><code>template &lt;typename...\u00a0T&gt;\nauto windows_error(int error_code, string_view message, const T&amp;... args) -\u2060&gt;\u00a0std::system_error;</code></pre> <p>Constructs a <code>std::system_error</code> object with the description of the form <pre><code>&lt;message&gt;: &lt;system-message&gt;\n</code></pre> where <code>&lt;message&gt;</code> is the formatted message and <code>&lt;system-message&gt;</code> is the system message corresponding to the error code. <code>error_code</code> is a Windows error code as given by <code>GetLastError</code>. If <code>error_code</code> is not a valid error code such as -1, the system message will look like \"error -1\".</p> <p>Example: <pre><code>// This throws a system_error with the description\n//   cannot open file 'madeup': The system cannot find the file\n</code></pre> specified. // or similar (system message may vary). const char *filename = \"madeup\"; LPOFSTRUCT of = LPOFSTRUCT(); HFILE file = OpenFile(filename, &amp;of, OF_READ); if (file == HFILE_ERROR) { throw fmt::windows_error(GetLastError(), \"cannot open file '{}'\", filename); } </p> <p></p>"},{"location":"api.html#stdostream-support","title":"<code>std::ostream</code> Support","text":"<p><code>fmt/ostream.h</code> provides <code>std::ostream</code> support including formatting of user-defined types that have an overloaded insertion operator (<code>operator&lt;&lt;</code>). In order to make a type formattable via <code>std::ostream</code> you should provide a <code>formatter</code> specialization inherited from <code>ostream_formatter</code>:</p> <pre><code>#include &lt;fmt/ostream.h&gt;\n\nstruct date {\n  int year, month, day;\n\n  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const date&amp; d) {\n    return os &lt;&lt; d.year &lt;&lt; '-' &lt;&lt; d.month &lt;&lt; '-' &lt;&lt; d.day;\n  }\n};\n\ntemplate &lt;&gt; struct fmt::formatter&lt;date&gt; : ostream_formatter {};\n\nstd::string s = fmt::format(\"The date is {}\", date{2012, 12, 9});\n// s == \"The date is 2012-12-9\"</code></pre> <pre><code>template &lt;typename T&gt;\nconstexpr auto streamed(const T&amp; value) -\u2060&gt;\u00a0detail::streamed_view&lt;T&gt;;</code></pre> <p>Returns a view that formats <code>value</code> via an ostream <code>operator&lt;&lt;</code>.</p> <p>Example: <pre><code>fmt::print(\"Current thread id: {}\\n\",\n           fmt::streamed(std::this_thread::get_id()));\n</code></pre> </p> <pre><code>template &lt;typename...\u00a0T&gt;\nvoid print(std::ostream&amp; os, format_string&lt;T...&gt; fmt, T&amp;&amp;... args);</code></pre> <p>Prints formatted data to the stream <code>os</code>.</p> <p>Example: <pre><code>fmt::print(cerr, \"Don't {}!\", \"panic\");\n</code></pre> </p> <p></p>"},{"location":"api.html#dynamic-argument-lists","title":"Dynamic Argument Lists","text":"<p>The header <code>fmt/args.h</code> provides <code>dynamic_format_arg_store</code>, a builder-like API that can be used to construct format argument lists dynamically.</p> <pre><code>template &lt;typename Context&gt;\nclass dynamic_format_arg_store;</code></pre> <p>A dynamic list of formatting arguments with storage.</p> <p>It can be implicitly converted into <code>fmt::basic_format_args</code> for passing into type-erased formatting functions such as <code>fmt::vformat</code>. </p> <pre><code>void push_back(const T&amp; arg);</code></pre> <p>Adds an argument into the dynamic store for later passing to a formatting function.</p> <p>Note that custom types and string types (but not string views) are copied into the store dynamically allocating memory if necessary.</p> <p>Example: <pre><code>fmt::dynamic_format_arg_store&lt;fmt::format_context&gt; store;\nstore.push_back(42);\nstore.push_back(\"abc\");\nstore.push_back(1.5f);\nstd::string result = fmt::vformat(\"{} and {} and {}\", store);\n</code></pre> </p> <pre><code>void push_back(std::reference_wrapper&lt;T&gt; arg);</code></pre> <p>Adds a reference to the argument into the dynamic store for later passing to a formatting function.</p> <p>Example: <pre><code>fmt::dynamic_format_arg_store&lt;fmt::format_context&gt; store;\nchar band[] = \"Rolling Stones\";\nstore.push_back(std::cref(band));\nband[9] = 'c'; // Changing str affects the output.\nstd::string result = fmt::vformat(\"{}\", store);\n// result == \"Rolling Scones\"\n</code></pre> </p> <pre><code>void push_back(const detail::named_arg&lt;char_type, T&gt;&amp; arg);</code></pre> <p>Adds named argument into the dynamic store for later passing to a formatting function. <code>std::reference_wrapper</code> is supported to avoid copying of the argument. The name is always copied into the store. </p> <pre><code>void clear();</code></pre> <p>Erase all elements from the store. </p> <pre><code>void reserve(size_t new_cap, size_t new_cap_named);</code></pre> <p>Reserves space to store at least <code>new_cap</code> arguments including <code>new_cap_named</code> named arguments. </p> <pre><code>size_t size();</code></pre> <p>Returns the number of elements in the store. </p> <p></p>"},{"location":"api.html#safe-printf","title":"Safe <code>printf</code>","text":"<p>The header <code>fmt/printf.h</code> provides <code>printf</code>-like formatting functionality. The following functions use printf format string syntax with the POSIX extension for positional arguments. Unlike their standard counterparts, the <code>fmt</code> functions are type-safe and throw an exception if an argument type doesn't match its format specification.</p> <pre><code>template &lt;typename...\u00a0T&gt;\nauto printf(string_view fmt, const T&amp;... args) -\u2060&gt;\u00a0int;</code></pre> <p>Formats <code>args</code> according to specifications in <code>fmt</code> and writes the output to <code>stdout</code>.</p> <p>Example:</p> <p>fmt::printf(\"Elapsed time: %.2f seconds\", 1.23); </p> <pre><code>template &lt;typename S, typename...\u00a0T, typename Char&gt;\nauto fprintf(std::FILE* f, const S&amp; fmt, const T&amp;... args) -\u2060&gt;\u00a0int;</code></pre> <p>Formats <code>args</code> according to specifications in <code>fmt</code> and writes the output to <code>f</code>.</p> <p>Example: <pre><code>fmt::fprintf(stderr, \"Don't %s!\", \"panic\");\n</code></pre> </p> <pre><code>template &lt;typename S, typename...\u00a0T, typename Char&gt;\nauto sprintf(const S&amp; fmt, const T&amp;... args) -\u2060&gt;\u00a0std::basic_string&lt;Char&gt;;</code></pre> <p>Formats <code>args</code> according to specifications in <code>fmt</code> and returns the result as as string.</p> <p>Example: <pre><code>std::string message = fmt::sprintf(\"The answer is %d\", 42);\n</code></pre> </p> <p></p>"},{"location":"api.html#wide-strings","title":"Wide Strings","text":"<p>The optional header <code>fmt/xchar.h</code> provides support for <code>wchar_t</code> and exotic character types.</p> <pre><code>template &lt;typename T&gt;\nstruct is_char;</code></pre> <pre><code>using wstring_view = basic_string_view&lt;wchar_t&gt;;</code></pre> <pre><code>using wformat_context = buffered_context&lt;wchar_t&gt;;</code></pre> <pre><code>template &lt;typename T&gt;\nauto to_wstring(const T&amp; value) -\u2060&gt;\u00a0std::wstring;</code></pre> <p>Converts <code>value</code> to <code>std::wstring</code> using the default format for type <code>T</code>. </p>"},{"location":"api.html#compatibility-with-c20-stdformat","title":"Compatibility with C++20 <code>std::format</code>","text":"<p>{fmt} implements nearly all of the C++20 formatting library with the following differences:</p> <ul> <li> <p>Names are defined in the <code>fmt</code> namespace instead of <code>std</code> to avoid   collisions with standard library implementations.</p> </li> <li> <p>Width calculation doesn't use grapheme clusterization. The latter has   been implemented in a separate branch but hasn't been integrated yet.</p> </li> <li> <p>The default floating-point representation in {fmt} uses the smallest   precision that provides round-trip guarantees similarly to other languages   like Java and Python. <code>std::format</code> is currently specified in terms of   <code>std::to_chars</code> which tries to generate the smallest number of characters   (ignoring redundant digits and sign in exponent) and may procude more   decimal digits than necessary.</p> </li> </ul>"},{"location":"get-started.html","title":"Get Started","text":"<p>Compile and run {fmt} examples online with Compiler Explorer.</p> <p>{fmt} is compatible with any build system. The next section describes its usage with CMake, while the Build Systems section covers the rest.</p>"},{"location":"get-started.html#cmake","title":"CMake","text":"<p>{fmt} provides two CMake targets: <code>fmt::fmt</code> for the compiled library and <code>fmt::fmt-header-only</code> for the header-only library. It is recommended to use the compiled library for improved build times.</p> <p>There are three primary ways to use {fmt} with CMake:</p> <ul> <li> <p>FetchContent: Starting from CMake 3.11, you can use <code>FetchContent</code> to automatically   download {fmt} as a dependency at configure time:</p> <pre><code>include(FetchContent)\n\nFetchContent_Declare(\n  fmt\n  GIT_REPOSITORY https://github.com/fmtlib/fmt\n  GIT_TAG        e69e5f977d458f2650bb346dadf2ad30c5320281) # 10.2.1\nFetchContent_MakeAvailable(fmt)\n\ntarget_link_libraries(&lt;your-target&gt; fmt::fmt)</code></pre> </li> <li> <p>Installed: You can find and use an installed version of   {fmt} in your <code>CMakeLists.txt</code> file as follows:</p> <pre><code>find_package(fmt)\ntarget_link_libraries(&lt;your-target&gt; fmt::fmt)</code></pre> </li> <li> <p>Embedded: You can add the {fmt} source tree to your project and include it   in your <code>CMakeLists.txt</code> file:</p> <pre><code>add_subdirectory(fmt)\ntarget_link_libraries(&lt;your-target&gt; fmt::fmt)</code></pre> </li> </ul>"},{"location":"get-started.html#installation","title":"Installation","text":""},{"location":"get-started.html#debianubuntu","title":"Debian/Ubuntu","text":"<p>To install {fmt} on Debian, Ubuntu, or any other Debian-based Linux distribution, use the following command:</p> <pre><code>apt install libfmt-dev</code></pre>"},{"location":"get-started.html#homebrew","title":"Homebrew","text":"<p>Install {fmt} on macOS using Homebrew:</p> <pre><code>brew install fmt</code></pre>"},{"location":"get-started.html#conda","title":"Conda","text":"<p>Install {fmt} on Linux, macOS, and Windows with Conda, using its conda-forge package:</p> <pre><code>conda install -c conda-forge fmt</code></pre>"},{"location":"get-started.html#vcpkg","title":"vcpkg","text":"<p>Download and install {fmt} using the vcpkg package manager:</p> <pre><code>git clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.sh\n./vcpkg integrate install\n./vcpkg install fmt</code></pre>"},{"location":"get-started.html#building-from-source","title":"Building from Source","text":"<p>CMake works by generating native makefiles or project files that can be used in the compiler environment of your choice. The typical workflow starts with:</p> <pre><code>mkdir build  # Create a directory to hold the build output.\ncd build\ncmake ..     # Generate native build scripts.</code></pre> <p>run in the <code>fmt</code> repository.</p> <p>If you are on a Unix-like system, you should now see a Makefile in the current directory. Now you can build the library by running <code>make</code>.</p> <p>Once the library has been built you can invoke <code>make test</code> to run the tests.</p> <p>You can control generation of the make <code>test</code> target with the <code>FMT_TEST</code> CMake option. This can be useful if you include fmt as a subdirectory in your project but don't want to add fmt's tests to your <code>test</code> target.</p> <p>To build a shared library set the <code>BUILD_SHARED_LIBS</code> CMake variable to <code>TRUE</code>:</p> <pre><code>cmake -DBUILD_SHARED_LIBS=TRUE ..</code></pre> <p>To build a static library with position-independent code (e.g. for linking it into another shared library such as a Python extension), set the <code>CMAKE_POSITION_INDEPENDENT_CODE</code> CMake variable to <code>TRUE</code>:</p> <pre><code>cmake -DCMAKE_POSITION_INDEPENDENT_CODE=TRUE ..</code></pre> <p>After building the library you can install it on a Unix-like system by running <code>sudo make install</code>.</p>"},{"location":"get-started.html#building-the-docs","title":"Building the Docs","text":"<p>To build the documentation you need the following software installed on your system:</p> <ul> <li>Python</li> <li>Doxygen</li> <li>MkDocs with <code>mkdocs-material</code>, <code>mkdocstrings</code>,   <code>pymdown-extensions</code> and <code>mike</code></li> </ul> <p>First generate makefiles or project files using CMake as described in the previous section. Then compile the <code>doc</code> target/project, for example:</p> <pre><code>make doc</code></pre> <p>This will generate the HTML documentation in <code>doc/html</code>.</p>"},{"location":"get-started.html#build-systems","title":"Build Systems","text":""},{"location":"get-started.html#build2","title":"build2","text":"<p>You can use build2, a dependency manager and a build system, to use {fmt}.</p> <p>Currently this package is available in these package repositories:</p> <ul> <li>https://cppget.org/fmt/ for released and published versions.</li> <li>https://github.com/build2-packaging/fmt for unreleased or custom versions.</li> </ul> <p>Usage:</p> <ul> <li><code>build2</code> package name: <code>fmt</code></li> <li>Library target name: <code>lib{fmt}</code></li> </ul> <p>To make your <code>build2</code> project depend on <code>fmt</code>:</p> <ul> <li> <p>Add one of the repositories to your configurations, or in your   <code>repositories.manifest</code>, if not already there:</p> <pre><code>:\nrole: prerequisite\nlocation: https://pkg.cppget.org/1/stable</code></pre> </li> <li> <p>Add this package as a dependency to your <code>manifest</code> file (example   for version 10):</p> <pre><code>depends: fmt ~10.0.0</code></pre> </li> <li> <p>Import the target and use it as a prerequisite to your own target   using <code>fmt</code> in the appropriate <code>buildfile</code>:</p> <pre><code>import fmt = fmt%lib{fmt}\nlib{mylib} : cxx{**} ... $fmt</code></pre> </li> </ul> <p>Then build your project as usual with <code>b</code> or <code>bdep update</code>.</p>"},{"location":"get-started.html#meson","title":"Meson","text":"<p>Meson WrapDB includes an <code>fmt</code> package.</p> <p>Usage:</p> <ul> <li>Install the <code>fmt</code> subproject from the WrapDB by running:<pre><code>meson wrap install fmt</code></pre> </li> </ul> <p>from the root of your project.</p> <ul> <li> <p>In your project's <code>meson.build</code> file, add an entry for the new subproject:</p> <pre><code>fmt = subproject('fmt')\nfmt_dep = fmt.get_variable('fmt_dep')</code></pre> </li> <li> <p>Include the new dependency object to link with fmt:</p> <pre><code>my_build_target = executable(\n  'name', 'src/main.cc', dependencies: [fmt_dep])</code></pre> </li> </ul> <p>Options:</p> <p>If desired, {fmt} can be built as a static library, or as a header-only library.</p> <p>For a static build, use the following subproject definition:</p> <pre><code>fmt = subproject('fmt', default_options: 'default_library=static')\nfmt_dep = fmt.get_variable('fmt_dep')</code></pre> <p>For the header-only version, use:</p> <pre><code>fmt = subproject('fmt', default_options: ['header-only=true'])\nfmt_dep = fmt.get_variable('fmt_header_only_dep')</code></pre>"},{"location":"get-started.html#android-ndk","title":"Android NDK","text":"<p>{fmt} provides Android.mk file that can be used to build the library with Android NDK.</p>"},{"location":"get-started.html#other","title":"Other","text":"<p>To use the {fmt} library with any other build system, add <code>include/fmt/base.h</code>, <code>include/fmt/format.h</code>, <code>include/fmt/format-inl.h</code>, <code>src/format.cc</code> and optionally other headers from a release archive or the git repository to your project, add <code>include</code> to include directories and make sure <code>src/format.cc</code> is compiled and linked with your code.</p>"},{"location":"syntax.html","title":"Format String Syntax","text":"<p>Formatting functions such as <code>fmt::format</code> and <code>fmt::print</code> use the same format string syntax described in this section.</p> <p>Format strings contain \"replacement fields\" surrounded by curly braces <code>{}</code>. Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: <code>{{</code> and <code>}}</code>.</p> <p>The grammar for a replacement field is as follows:</p> <p></p> <pre><code>replacement_field ::= \"{\" [arg_id] [\":\" (format_spec | chrono_format_spec)] \"}\"\narg_id            ::= integer | identifier\ninteger           ::= digit+\ndigit             ::= \"0\"...\"9\"\nidentifier        ::= id_start id_continue*\nid_start          ::= \"a\"...\"z\" | \"A\"...\"Z\" | \"_\"\nid_continue       ::= id_start | digit</code>\n</pre> <p>In less formal terms, the replacement field can start with an arg_id that specifies the argument whose value is to be formatted and inserted into the output instead of the replacement field. The arg_id is optionally followed by a format_spec, which is preceded by a colon <code>':'</code>. These specify a non-default format for the replacement value.</p> <p>See also the Format Specification Mini-Language section.</p> <p>If the numerical arg_ids in a format string are 0, 1, 2, ... in sequence, they can all be omitted (not just some) and the numbers 0, 1, 2, ... will be automatically inserted in that order.</p> <p>Named arguments can be referred to by their names or indices.</p> <p>Some simple format string examples:</p> <pre><code>\"First, thou shalt count to {0}\" // References the first argument\n\"Bring me a {}\"                  // Implicitly references the first argument\n\"From {} to {}\"                  // Same as \"From {0} to {1}\"\n</code></pre> <p>The format_spec field contains a specification of how the value should be presented, including such details as field width, alignment, padding, decimal precision and so on. Each value type can define its own \"formatting mini-language\" or interpretation of the format_spec.</p> <p>Most built-in types support a common formatting mini-language, which is described in the next section.</p> <p>A format_spec field can also include nested replacement fields in certain positions within it. These nested replacement fields can contain only an argument id; format specifications are not allowed. This allows the formatting of a value to be dynamically specified.</p> <p>See the Format Examples section for some examples.</p>"},{"location":"syntax.html#format-specification-mini-language","title":"Format Specification Mini-Language","text":"<p>\"Format specifications\" are used within replacement fields contained within a format string to define how individual values are presented. Each formattable type may define how the format specification is to be interpreted.</p> <p>Most built-in types implement the following options for format specifications, although some of the formatting options are only supported by the numeric types.</p> <p>The general form of a standard format specifier is:</p> <p></p> <pre><code>format_spec ::= [[fill]align][sign][\"#\"][\"0\"][width][\".\" precision][\"L\"][type]\nfill        ::= &lt;a character other than '{' or '}'&gt;\nalign       ::= \"&lt;\" | \"&gt;\" | \"^\"\nsign        ::= \"+\" | \"-\" | \" \"\nwidth       ::= integer | \"{\" [arg_id] \"}\"\nprecision   ::= integer | \"{\" [arg_id] \"}\"\ntype        ::= \"a\" | \"A\" | \"b\" | \"B\" | \"c\" | \"d\" | \"e\" | \"E\" | \"f\" | \"F\" |\n                \"g\" | \"G\" | \"o\" | \"p\" | \"s\" | \"x\" | \"X\" | \"?\"</code>\n</pre> <p>The fill character can be any Unicode code point other than <code>'{'</code> or <code>'}'</code>. The presence of a fill character is signaled by the character following it, which must be one of the alignment options. If the second character of format_spec is not a valid alignment option, then it is assumed that both the fill character and the alignment option are absent.</p> <p>The meaning of the various alignment options is as follows:</p> Option Meaning <code>'&lt;'</code>      Forces the field to be left-aligned within the available space (this is the     default for most objects).    <code>'&gt;'</code>      Forces the field to be right-aligned within the available space (this is     the default for numbers).    <code>'^'</code> Forces the field to be centered within the available space. <p>Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case.</p> <p>The sign option is only valid for floating point and signed integer types, and can be one of the following:</p> Option Meaning <code>'+'</code>      Indicates that a sign should be used for both nonnegative as well as     negative numbers.    <code>'-'</code>      Indicates that a sign should be used only for negative numbers (this is the     default behavior).    space      Indicates that a leading space should be used on nonnegative numbers, and a     minus sign on negative numbers.    <p>The <code>'#'</code> option causes the \"alternate form\" to be used for the conversion. The alternate form is defined differently for different types. This option is only valid for integer and floating-point types. For integers, when binary, octal, or hexadecimal output is used, this option adds the prefix respective <code>\"0b\"</code> (<code>\"0B\"</code>), <code>\"0\"</code>, or <code>\"0x\"</code> (<code>\"0X\"</code>) to the output value. Whether the prefix is lower-case or upper-case is determined by the case of the type specifier, for example, the prefix <code>\"0x\"</code> is used for the type <code>'x'</code> and <code>\"0X\"</code> is used for <code>'X'</code>. For floating-point numbers the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for <code>'g'</code> and <code>'G'</code> conversions, trailing zeros are not removed from the result.</p> <p>width is a decimal integer defining the minimum field width. If not specified, then the field width will be determined by the content.</p> <p>Preceding the width field by a zero (<code>'0'</code>) character enables sign-aware zero-padding for numeric types. It forces the padding to be placed after the sign or base (if any) but before the digits. This is used for printing fields in the form \"+000000120\". This option is only valid for numeric types and it has no effect on formatting of infinity and NaN. This option is ignored when any alignment specifier is present.</p> <p>The precision is a decimal number indicating how many digits should be displayed after the decimal point for a floating-point value formatted with <code>'f'</code> and <code>'F'</code>, or before and after the decimal point for a floating-point value formatted with <code>'g'</code> or <code>'G'</code>. For non-number types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is not allowed for integer, character, Boolean, and pointer values. Note that a C string must be null-terminated even if precision is specified.</p> <p>The <code>'L'</code> option uses the current locale setting to insert the appropriate number separator characters. This option is only valid for numeric types.</p> <p>Finally, the type determines how the data should be presented.</p> <p>The available string presentation types are:</p> Type Meaning <code>'s'</code>      String format. This is the default type for strings and may be omitted.    <code>'?'</code> Debug format. The string is quoted and special characters escaped. none The same as <code>'s'</code>. <p>The available character presentation types are:</p> Type Meaning <code>'c'</code>      Character format. This is the default type for characters and may be     omitted.    <code>'?'</code> Debug format. The character is quoted and special characters escaped. none The same as <code>'c'</code>. <p>The available integer presentation types are:</p> Type Meaning <code>'b'</code>      Binary format. Outputs the number in base 2. Using the <code>'#'</code>     option with this type adds the prefix <code>\"0b\"</code> to the output value.        <code>'B'</code>      Binary format. Outputs the number in base 2. Using the <code>'#'</code>     option with this type adds the prefix <code>\"0B\"</code> to the output value.    <code>'c'</code> Character format. Outputs the number as a character. <code>'d'</code> Decimal integer. Outputs the number in base 10. <code>'o'</code> Octal format. Outputs the number in base 8. <code>'x'</code>      Hex format. Outputs the number in base 16, using lower-case letters for the     digits above 9. Using the <code>'#'</code> option with this type adds the     prefix <code>\"0x\"</code> to the output value.    <code>'X'</code>      Hex format. Outputs the number in base 16, using upper-case letters for the     digits above 9. Using the <code>'#'</code> option with this type adds the     prefix <code>\"0X\"</code> to the output value.    none The same as <code>'d'</code>. <p>Integer presentation types can also be used with character and Boolean values with the only exception that <code>'c'</code> cannot be used with <code>bool</code>. Boolean values are formatted using textual representation, either <code>true</code> or <code>false</code>, if the presentation type is not specified.</p> <p>The available presentation types for floating-point values are:</p> Type Meaning <code>'a'</code>      Hexadecimal floating point format. Prints the number in base 16 with     prefix <code>\"0x\"</code> and lower-case letters for digits above 9.     Uses <code>'p'</code> to indicate the exponent.    <code>'A'</code>      Same as <code>'a'</code> except it uses upper-case letters for the     prefix, digits above 9 and to indicate the exponent.    <code>'e'</code>      Exponent notation. Prints the number in scientific notation using     the letter 'e' to indicate the exponent.    <code>'E'</code>      Exponent notation. Same as <code>'e'</code> except it uses an     upper-case <code>'E'</code> as the separator character.    <code>'f'</code> Fixed point. Displays the number as a fixed-point number. <code>'F'</code>      Fixed point. Same as <code>'f'</code>, but converts <code>nan</code>     to <code>NAN</code> and <code>inf</code> to <code>INF</code>.    <code>'g'</code> <p>General format. For a given precision <code>p &gt;= 1</code>,     this rounds the number to <code>p</code> significant digits and then     formats the result in either fixed-point format or in scientific     notation, depending on its magnitude.</p> <p>A precision of <code>0</code> is treated as equivalent to a precision     of <code>1</code>.</p> <code>'G'</code>      General format. Same as <code>'g'</code> except switches to     <code>'E'</code> if the number gets too large. The representations of     infinity and NaN are uppercased, too.    none      Similar to <code>'g'</code>, except that the default precision is as     high as needed to represent the particular value.    <p>The available presentation types for pointers are:</p> Type Meaning <code>'p'</code>      Pointer format. This is the default type for pointers and may be omitted.    none The same as <code>'p'</code>."},{"location":"syntax.html#chrono-format-specifications","title":"Chrono Format Specifications","text":"<p>Format specifications for chrono duration and time point types as well as <code>std::tm</code> have the following syntax:</p> <p></p> <pre><code>chrono_format_spec ::= [[fill]align][width][\".\" precision][chrono_specs]\nchrono_specs       ::= conversion_spec |\n                       chrono_specs (conversion_spec | literal_char)\nconversion_spec    ::= \"%\" [padding_modifier] [locale_modifier] chrono_type\nliteral_char       ::= &lt;a character other than '{', '}' or '%'&gt;\npadding_modifier   ::= \"-\" | \"_\"  | \"0\"\nlocale_modifier    ::= \"E\" | \"O\"\nchrono_type        ::= \"a\" | \"A\" | \"b\" | \"B\" | \"c\" | \"C\" | \"d\" | \"D\" | \"e\" |\n                       \"F\" | \"g\" | \"G\" | \"h\" | \"H\" | \"I\" | \"j\" | \"m\" | \"M\" |\n                       \"n\" | \"p\" | \"q\" | \"Q\" | \"r\" | \"R\" | \"S\" | \"t\" | \"T\" |\n                       \"u\" | \"U\" | \"V\" | \"w\" | \"W\" | \"x\" | \"X\" | \"y\" | \"Y\" |\n                       \"z\" | \"Z\" | \"%\"</code>\n</pre> <p>Literal chars are copied unchanged to the output. Precision is valid only for <code>std::chrono::duration</code> types with a floating-point representation type.</p> <p>The available presentation types (chrono_type) are:</p> Type Meaning <code>'a'</code>      The abbreviated weekday name, e.g. \"Sat\". If the value does not contain a     valid weekday, an exception of type <code>format_error</code> is thrown.    <code>'A'</code>      The full weekday name, e.g. \"Saturday\". If the value does not contain a     valid weekday, an exception of type <code>format_error</code> is thrown.    <code>'b'</code>      The abbreviated month name, e.g. \"Nov\". If the value does not contain a     valid month, an exception of type <code>format_error</code> is thrown.    <code>'B'</code>      The full month name, e.g. \"November\". If the value does not contain a valid     month, an exception of type <code>format_error</code> is thrown.    <code>'c'</code>      The date and time representation, e.g. \"Sat Nov 12 22:04:00 1955\". The     modified command <code>%Ec</code> produces the locale's alternate date and     time representation.    <code>'C'</code>      The year divided by 100 using floored division, e.g. \"19\". If the result     is a single decimal digit, it is prefixed with 0. The modified command     <code>%EC</code> produces the locale's alternative representation of the     century.    <code>'d'</code>      The day of month as a decimal number. If the result is a single decimal     digit, it is prefixed with 0. The modified command <code>%Od</code>     produces the locale's alternative representation.    <code>'D'</code> Equivalent to <code>%m/%d/%y</code>, e.g. \"11/12/55\". <code>'e'</code>      The day of month as a decimal number. If the result is a single decimal     digit, it is prefixed with a space. The modified command <code>%Oe</code>     produces the locale's alternative representation.    <code>'F'</code> Equivalent to <code>%Y-%m-%d</code>, e.g. \"1955-11-12\". <code>'g'</code>      The last two decimal digits of the ISO week-based year. If the result is a     single digit it is prefixed by 0.    <code>'G'</code>      The ISO week-based year as a decimal number. If the result is less than     four digits it is left-padded with 0 to four digits.    <code>'h'</code> Equivalent to <code>%b</code>, e.g. \"Nov\". <code>'H'</code>      The hour (24-hour clock) as a decimal number. If the result is a single     digit, it is prefixed with 0. The modified command <code>%OH</code>     produces the locale's alternative representation.    <code>'I'</code>      The hour (12-hour clock) as a decimal number. If the result is a single     digit, it is prefixed with 0. The modified command <code>%OI</code>     produces the locale's alternative representation.    <code>'j'</code>      If the type being formatted is a specialization of duration, the decimal     number of days without padding. Otherwise, the day of the year as a decimal     number. Jan 1 is 001. If the result is less than three digits, it is     left-padded with 0 to three digits.    <code>'m'</code>      The month as a decimal number. Jan is 01. If the result is a single digit,     it is prefixed with 0. The modified command <code>%Om</code> produces the     locale's alternative representation.    <code>'M'</code>      The minute as a decimal number. If the result is a single digit, it     is prefixed with 0. The modified command <code>%OM</code> produces the     locale's alternative representation.    <code>'n'</code> A new-line character. <code>'p'</code> The AM/PM designations associated with a 12-hour clock. <code>'q'</code> The duration's unit suffix. <code>'Q'</code>      The duration's numeric value (as if extracted via <code>.count()</code>).    <code>'r'</code> The 12-hour clock time, e.g. \"10:04:00 PM\". <code>'R'</code> Equivalent to <code>%H:%M</code>, e.g. \"22:04\". <code>'S'</code>      Seconds as a decimal number. If the number of seconds is less than 10, the     result is prefixed with 0. If the precision of the input cannot be exactly     represented with seconds, then the format is a decimal floating-point number     with a fixed format and a precision matching that of the precision of the     input (or to a microseconds precision if the conversion to floating-point     decimal seconds cannot be made within 18 fractional digits). The modified     command <code>%OS</code> produces the locale's alternative representation.    <code>'t'</code> A horizontal-tab character. <code>'T'</code> Equivalent to <code>%H:%M:%S</code>. <code>'u'</code>      The ISO weekday as a decimal number (1-7), where Monday is 1. The modified     command <code>%Ou</code> produces the locale's alternative representation.    <code>'U'</code>      The week number of the year as a decimal number. The first Sunday of the     year is the first day of week 01. Days of the same year prior to that are     in week 00. If the result is a single digit, it is prefixed with 0.     The modified command <code>%OU</code> produces the locale's alternative     representation.    <code>'V'</code>      The ISO week-based week number as a decimal number. If the result is a     single digit, it is prefixed with 0. The modified command <code>%OV</code>     produces the locale's alternative representation.    <code>'w'</code>      The weekday as a decimal number (0-6), where Sunday is 0. The modified     command <code>%Ow</code> produces the locale's alternative representation.    <code>'W'</code>      The week number of the year as a decimal number. The first Monday of the     year is the first day of week 01. Days of the same year prior to that are     in week 00. If the result is a single digit, it is prefixed with 0.     The modified command <code>%OW</code> produces the locale's alternative     representation.    <code>'x'</code>      The date representation, e.g. \"11/12/55\". The modified command     <code>%Ex</code> produces the locale's alternate date representation.    <code>'X'</code>      The time representation, e.g. \"10:04:00\". The modified command     <code>%EX</code> produces the locale's alternate time representation.    <code>'y'</code>      The last two decimal digits of the year. If the result is a single digit     it is prefixed by 0. The modified command <code>%Oy</code> produces the     locale's alternative representation. The modified command <code>%Ey</code>     produces the locale's alternative representation of offset from     <code>%EC</code> (year only).    <code>'Y'</code>      The year as a decimal number. If the result is less than four digits it is     left-padded with 0 to four digits. The modified command <code>%EY</code>     produces the locale's alternative full year representation.    <code>'z'</code>      The offset from UTC in the ISO 8601:2004 format. For example -0430 refers     to 4 hours 30 minutes behind UTC. If the offset is zero, +0000 is used.     The modified commands <code>%Ez</code> and <code>%Oz</code> insert a     <code>:</code> between the hours and minutes: -04:30. If the offset     information is not available, an exception of type     <code>format_error</code> is thrown.    <code>'Z'</code>      The time zone abbreviation. If the time zone abbreviation is not available,     an exception of type <code>format_error</code> is thrown.    <code>'%'</code> A % character. <p>Specifiers that have a calendaric component such as <code>'d'</code> (the day of month) are valid only for <code>std::tm</code> and time points but not durations.</p> <p>The available padding modifiers (padding_modifier) are:</p> Type Meaning <code>'_'</code> Pad a numeric result with spaces. <code>'-'</code> Do not pad a numeric result string. <code>'0'</code> Pad a numeric result string with zeros. <p>These modifiers are only supported for the <code>'H'</code>, <code>'I'</code>, <code>'M'</code>, <code>'S'</code>, <code>'U'</code>, <code>'V'</code>, <code>'W'</code>, <code>'Y'</code>, <code>'d'</code>, <code>'j'</code> and <code>'m'</code> presentation types.</p>"},{"location":"syntax.html#range-format-specifications","title":"Range Format Specifications","text":"<p>Format specifications for range types have the following syntax:</p> <pre><code>range_format_spec ::= [\"n\"][range_type][range_underlying_spec]</code>\n</pre> <p>The <code>'n'</code> option formats the range without the opening and closing brackets.</p> <p>The available presentation types for <code>range_type</code> are:</p> Type Meaning none Default format. <code>'s'</code> String format. The range is formatted as a string. <code>'?\u2060s'</code> Debug format. The range is formatted as an escaped string. <p>If <code>range_type</code> is <code>'s'</code> or <code>'?s'</code>, the range element type must be a character type. The <code>'n'</code> option and <code>range_underlying_spec</code> are mutually exclusive with <code>'s'</code> and <code>'?s'</code>.</p> <p>The <code>range_underlying_spec</code> is parsed based on the formatter of the range's element type.</p> <p>By default, a range of characters or strings is printed escaped and quoted. But if any <code>range_underlying_spec</code> is provided (even if it is empty), then the characters or strings are printed according to the provided specification.</p> <p>Examples:</p> <pre><code>fmt::print(\"{}\", std::vector{10, 20, 30});\n// Output: [10, 20, 30]\nfmt::print(\"{::#x}\", std::vector{10, 20, 30});\n// Output: [0xa, 0x14, 0x1e]\nfmt::print(\"{}\", std::vector{'h', 'e', 'l', 'l', 'o'});\n// Output: ['h', 'e', 'l', 'l', 'o']\nfmt::print(\"{:n}\", std::vector{'h', 'e', 'l', 'l', 'o'});\n// Output: 'h', 'e', 'l', 'l', 'o'\nfmt::print(\"{:s}\", std::vector{'h', 'e', 'l', 'l', 'o'});\n// Output: \"hello\"\nfmt::print(\"{:?s}\", std::vector{'h', 'e', 'l', 'l', 'o', '\\n'});\n// Output: \"hello\\n\"\nfmt::print(\"{::}\", std::vector{'h', 'e', 'l', 'l', 'o'});\n// Output: [h, e, l, l, o]\nfmt::print(\"{::d}\", std::vector{'h', 'e', 'l', 'l', 'o'});\n// Output: [104, 101, 108, 108, 111]\n</code></pre>"},{"location":"syntax.html#format-examples","title":"Format Examples","text":"<p>This section contains examples of the format syntax and comparison with the printf formatting.</p> <p>In most of the cases the syntax is similar to the printf formatting, with the addition of the <code>{}</code> and with <code>:</code> used instead of <code>%</code>. For example, <code>\"%03.2f\"</code> can be translated to <code>\"{:03.2f}\"</code>.</p> <p>The new format syntax also supports new and different options, shown in the following examples.</p> <p>Accessing arguments by position:</p> <pre><code>fmt::format(\"{0}, {1}, {2}\", 'a', 'b', 'c');\n// Result: \"a, b, c\"\nfmt::format(\"{}, {}, {}\", 'a', 'b', 'c');\n// Result: \"a, b, c\"\nfmt::format(\"{2}, {1}, {0}\", 'a', 'b', 'c');\n// Result: \"c, b, a\"\nfmt::format(\"{0}{1}{0}\", \"abra\", \"cad\");  // arguments' indices can be repeated\n// Result: \"abracadabra\"\n</code></pre> <p>Aligning the text and specifying a width:</p> <pre><code>fmt::format(\"{:&lt;30}\", \"left aligned\");\n// Result: \"left aligned                  \"\nfmt::format(\"{:&gt;30}\", \"right aligned\");\n// Result: \"                 right aligned\"\nfmt::format(\"{:^30}\", \"centered\");\n// Result: \"           centered           \"\nfmt::format(\"{:*^30}\", \"centered\");  // use '*' as a fill char\n// Result: \"***********centered***********\"\n</code></pre> <p>Dynamic width:</p> <pre><code>fmt::format(\"{:&lt;{}}\", \"left aligned\", 30);\n// Result: \"left aligned                  \"\n</code></pre> <p>Dynamic precision:</p> <pre><code>fmt::format(\"{:.{}f}\", 3.14, 1);\n// Result: \"3.1\"\n</code></pre> <p>Replacing <code>%+f</code>, <code>%-f</code>, and <code>% f</code> and specifying a sign:</p> <pre><code>fmt::format(\"{:+f}; {:+f}\", 3.14, -3.14);  // show it always\n// Result: \"+3.140000; -3.140000\"\nfmt::format(\"{: f}; {: f}\", 3.14, -3.14);  // show a space for positive numbers\n// Result: \" 3.140000; -3.140000\"\nfmt::format(\"{:-f}; {:-f}\", 3.14, -3.14);  // show only the minus -- same as '{:f}; {:f}'\n// Result: \"3.140000; -3.140000\"\n</code></pre> <p>Replacing <code>%x</code> and <code>%o</code> and converting the value to different bases:</p> <pre><code>fmt::format(\"int: {0:d};  hex: {0:x};  oct: {0:o}; bin: {0:b}\", 42);\n// Result: \"int: 42;  hex: 2a;  oct: 52; bin: 101010\"\n// with 0x or 0 or 0b as prefix:\nfmt::format(\"int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}\", 42);\n// Result: \"int: 42;  hex: 0x2a;  oct: 052;  bin: 0b101010\"\n</code></pre> <p>Padded hex byte with prefix and always prints both hex characters:</p> <pre><code>fmt::format(\"{:#04x}\", 0);\n// Result: \"0x00\"\n</code></pre> <p>Box drawing using Unicode fill:</p> <pre><code>fmt::print(\n    \"\u250c{0:\u2500^{2}}\u2510\\n\"\n    \"\u2502{1: ^{2}}\u2502\\n\"\n    \"\u2514{0:\u2500^{2}}\u2518\\n\", \"\", \"Hello, world!\", 20);\n</code></pre> <p>prints:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Hello, world!    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Using type-specific formatting:</p> <pre><code>#include &lt;fmt/chrono.h&gt;\n\nauto t = tm();\nt.tm_year = 2010 - 1900;\nt.tm_mon = 7;\nt.tm_mday = 4;\nt.tm_hour = 12;\nt.tm_min = 15;\nt.tm_sec = 58;\nfmt::print(\"{:%Y-%m-%d %H:%M:%S}\", t);\n// Prints: 2010-08-04 12:15:58\n</code></pre> <p>Using the comma as a thousands separator:</p> <pre><code>#include &lt;fmt/format.h&gt;\n\nauto s = fmt::format(std::locale(\"en_US.UTF-8\"), \"{:L}\", 1234567890);\n// s == \"1,234,567,890\"\n</code></pre>"}]}